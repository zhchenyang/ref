# VimL 的主要特定

VimL 的优缺点：

* 优点：
  1. 与Vim 的操作无间密合
  2. 编辑器、解释器、文档手册一体化

* 缺点：
  1. 只能在 Vim 环境下运行
  2. 运行速度偏慢

## hello world! 的四种写法

惯例

### 速观派

直接在vim 中输入如下命令：

```vim
:echo 'Hello world!'
```
TIPS: 单引号和双引号的区别，一个不转义一个转义。

### 正规派

将命令保存到 `.vim` 文件中，便是一个 vim 脚本了，这是比较正常的用法了。

```vim
" tmp.vim
echo 'Hello world!'
finish
```

TIPS:

1. `"` 开头为注释行
2. 脚本文件中命令前不用加冒号
3. `finish` 表示脚本结束，但非要，如无，则执行至文件最后一行

接下来便可以使用 `:source file.vim`:

```vim
:source tmp.vim
```

如果正在编辑此文件则可是使用 `%` 替代文件路径：

```vim
:source %
```

TIPS:

1. `source` 可以简写为 `so` 
2. 也可以通过定义按键

  ```vim
  :nnoremap <F5>:update<CR>:source %<CR>
  ```

  可以将此内容放入 `.vimrc` 中，不过最好放在 `~/.vim/ftplugin/vim.vim` 中加上局部参数使其只影响 `*.vim` 文件：

  ```vim
  :nnoremap <buffer> <F5>:update<CR>:source %<CR>
  ```
QUESTION: `:` 的作用

### 测试派

进入 `Ex` 模式，可以快速验证一些细节：

```vim
" Ex mode
echo '0' == 0
echo 'hello world!'
```

### 索隐派

```bash
vim \
  -e \ # 以 Ex 模式启动 vim
  -S \ # 启动后立即启动一个脚本
  tmp.vim
```

**补充**

`ex` 命令就是 `:s` 全局替换命令。

## 同源 ex 命令行

VimL 就是富有程序流程控制的 `ex` 命令。

```
VimL = ex command + flow
```

### 第一个脚本：vimrc

`.vimrc` 也是 VimL 的脚本

```vim
set number
set wrap
nnoremap j gj
nnoremap k gk
```

### 流程控制也是 ex 命令

在 VimL 中每一行都是 ex 命令，作为一门脚本语言，最常见的，创建变量要用 `let`，调用函数需要用 `call` 命令。从这个意义上讲，Viml 和 Shell 脚本是很类似的。把命令语句保存到文件中就成了脚本。

在 VimL 中 `if`、`for`、`while` 也可以当做拓展的 ex 命令处理。其可以省略冒号，可以想其他命令无歧义时候任意简写。在写脚本时，强烈建议都写命令全称。

TIPS: 

* `\` 换行符不像其他语言写在行后，而是写在行前
* 不推荐一行写多个语句，写的话用 `|` 分隔

### 关键命令列表

1. let call (unlet)
2. if for while function try（endif, endfor, end...)
3. break continue retuen finish
4. echo echomsg echoerr
5. execute normal source
6. set map command
7. augroup autocmd
8. wincmd tabnext
9. other

其中，第 5 类恰好是个分界线，之上的是形成 VimL 语言的关键命令，之下是作为 Vim 编辑器的重要命令。没有后面的编辑器命令，纯 VimL 语言也可以写脚本，作为一种（没有 什么优势的）通用脚本而已；只有利用后面的编辑器命令，才可以调控 Vim。

总之，语句与命令，是联结 VimL 与 Vim 的重要纽带

## 弱类型和强作用域

“弱类型”不是 VimL 的特点，是几乎所有脚本语言的特点。准确地说是变量无类型，但值有类型。变量作用域是编程的另一个重要概念，也几乎每个语言都要管理的任务。这里说 VimL 具有“强作用域”的特点，是指它提供了一种简明的语法，让用户强调变量的作用域范围。

### VimL 语言级的作用域 g: l: s: a:

变量作用域的意义是指该变量在什么范围内可见，可以被操作（读取和赋值）。在 VimL 中，每个变量前都可以加上冒号前缀，表示该变量的作用域。不过有两条规则：

1. 在一些上下文环境中，可以省略作用域，等效与加上了默认的作用域前缀
2. 一些作用域只在特定的环境中使用

VimL 主要包含四种作用域：

1. `g:` 全局作用域。全局变量就是在当前 vim 会话环境中，在任何脚本中，任何 ex 命令中都可以引用的变量。所以**函数之外的命令语句默认都是全局的**。
2. `l:` 局部作用域。只在当前执行的函数体内使用的变量，在**函数内变量默认为局部变量**，**局部变量也只能在函数体内使用**。
3. `s:` 脚本作用域。只有当前脚本内可以引用的变量，包括在脚本的函数体内。
4. `a:` 参数作用域。特指函数的参数，在函数体内，要引入传入的实参，就得加上 `a:`。但是定义函数的形参时不可加上。 前缀。`a:` 还隐含一个限定是只读性，即不能在函数体内修改参数。

变量作用域使用原则：

1. 尽量少用全局变量，容易混乱使用，难于管理
2. 局部变量前缀一般可以省略
3. 在写 vim 脚本时，函数外的代码，能用 s: 变量就尽量用 s: 变量。对于比较大的脚本变量（如字典），想对外分享，也宁可先定义为 s: 变量，再定义一个全局可访问的函数来返回这个脚本变量。
4. 参数变量，a: 是语法强制要求，漏写了 a: 往往是个错误，（如果它没报错，恰好与同名局部变量冲突了，那是更糟糕与难以觉察的错误）也是初写 VimL 函数最容易犯的语法错误。

### 实体作用域 b: w: t:

Vim 作为一个可视化的编辑器，给用户呈现的，能让用户交互地操作的实体对象主要有 bufer（缓冲文件），window（窗口），tabpage（标签页）。可以把它们想象为互有关系的容器：

* 缓冲对应着一个正在编辑中的文件，在不细究的情况下可认为与文件等同。（不过不一定对应着硬盘上的一个文件，比如新建的尚未保存的文件，以及一些特殊缓冲文件）缓冲也可认为是容纳着文件中所有文本行的容器，就像是简单的字符串列表了。

* 窗口是用于展示缓冲文件的一部分在屏幕上的容器。Vim 可编辑的文件很大，极有可能在一个屏幕窗口中无法显示文件的所有内容，所以窗口对应于缓冲文件还有个可视范围。**一个窗口在一个时刻只能容纳一个缓冲文件，但在不同时刻可以对应不同的缓冲文件**。

* 标签页是可以同时容纳不同的窗口的另一层更大的容器。原始的 Vi 没有标签页，标签页是 Vim 的扩展功能。标签页极大增强 Vim 的可视范围，可认为窗口是平面的，再叠上标签页就是（伪）立体的了。

* 一个缓冲文件可以展示在不同的窗口或（与）标签页中。所有已展示在某个窗口（包括在其他标签页的窗口）的缓冲文件都是“已加载”状态，其他曾经被编辑过但当前不可见的缓冲文件则是“未加载”状态，不过 Vim 仍然记录着所有这些缓冲文件的列表。

有了这些概念，对 VimL 中的另外三个作用域前缀 b: w: t: 就容易理解了。其意即指一个变量与特定的缓冲文件、窗口或标签页相关联的，以 b: 举例说明。

* `b:varname` 表示在当前缓冲文件（实体对象）中存在一个名为 varname 的变量。

* VimL 语句在执行过程中，只能直接引用当前缓冲文件的 b: 变量，如果要引用其他缓冲文件的变量，要么先用其他命令将目标缓冲文件切换为当前编辑的缓冲文件，或者调用其他的内置函数来访问。

* 如果一个缓冲文件“消失”了，那么与之关联的所有 b: 变量也消失了。

* 窗口与标签页的“消失”能比较形象与容易地理解，关闭了就算消失了。但 Vim 内部对缓冲的管理比较复杂，未必是从窗口上不见了就代表“消失”了。

* 不过在一般 VimL 编程中，可暂不必深究缓冲文件什么时候“消失”。只要记着一个 b: 变量必定与一个缓冲文件关联着，不同的缓冲文件使用相同的 b: 变量是安全的，它们互不影响。

### 作用域前缀其实是一个字典

键入：

```vim
:let x = 1
:echo x
:echo g:x
:echo g:.x
:echo g:['x']
:echo g:
```
最后要指出的是，局部作用域 l: 与参数作用域 a: 不能像 s: 或 b: 这样当作整体的字典变量，是两个例外。VimL 这样处理的原因，可能一是没必要，二是没效率。


### 其他特殊变量 `$` `v:` `&`

* `$`：环境变量
* `v:`：vim 内部自定义变量，不能增删修改
* `&`：选项的值，相当于把选项变量化

```vim
echo $MYVIMRC  " like bash $
echo v:true
```

## 自动加载脚本机制

前文已提及，vim 脚本主要用‘:source’命令加载，然而很多情况下又不需要手动执行该命令。只要将脚本放在特定的目录下，vim 就有个机制能自动搜寻并加载。

### Vim 插件搜索目录

首先要知道有 `&runtimepath`(常简写为 `&rtp`)这个选项。它与系统的环境变量 `$PATH` 有点类似，就是一组有序的目录名称，用于 Vim 在许多不同情况下搜寻 *.vim 脚本文件的。

当一个文件类型 `&filetype` 被识别时，Vim 会从所有 `&rtp` 目录下的 `ftplugin/` 子目录中搜索以文件类型开始的脚本文件，然后加载执行。

### VimL 的自动加载函数

Vim 一直有个追求的目标是启动快。当插件越来越多时，vim 启动时要解析大量的脚本文件，就会被拖慢了。这时就出现了一个 autoload 自动加载函数的机制，这个巧妙的方法可算是 VimL 发展的一个里程碑吧。而在这之前，须由用户在 plugin/*.vim 的复杂脚本中用极具巧妙的编程技巧，才好实现延时加载。

TOBECONTINUE

# VimL 基本语法

## 变量与类型

VimL 语言的变量规则与其他大多数语言一样，可以(只允许)由字母、数字与下划线组成，且不能以数字开头。特殊之处在于还可以在变量名之前添加可选的作用域前缀，如“g: l: s: b: w: t:”。

VimL 所支持的变量(值)类型可由帮助(‘:help type()’)查看。其中最主要最常用的有数字(number)、字符串(string)、列表(list)与字典(dictionary)四种，或者可以再进一步归纳为三种，因为前两种(数字与字符串)在绝大数情况下自动转换，在使用时几乎不必考虑其类型差别，只须知道它表示“一个值”，所以也称作标量。而列表与字典变量则是“多个值”的集合，所不同在于获取其中某个值的索引方式不同。

### 标量：数字和字符串

数字也就是 `int`。不赘述。

支持加减乘除模 `+-*/%`

字符即 `str`，有以下几个原则：

* 一般使用单引号表示字符串，如 string，毕竟双引号还可用于行末注释，尽量避免混淆。
* 如果需要使用转义如 `\n` `\t`，则使用双引号，单引号不支持转义。
* 如果字符串包含一种引号，则使用另一种引号括起整个字符串。
* 如果有包含一层引用，则内外层用不同的引号。

TIPS：字符串和整数会自动转换

* 数字转字符串
* 字符串转数字，只截取前面最像数字的部分，如果没有数字开头，则返回 0。
* 二、八、十六进制表示的数字会自动转换为十进制。

```vim
echo 'string' . 123
echo '123'
echo '123' + 1
echo '123string' + 1
echo '1.23string' + 1
echo 'string123' + 1
```

### list

参考：

```vim
let list = [0, 1, 2, 3]
call add(list, 4)
call add(list, 5)
echo list
call remove(list, -1) | echo list
call remove(list, 1) | echo list
call len(list)
```

TIPS：索引从 0 开始

### dictionary

参考：

```vim
let dict = {'x':1, 'y':2, 'z': 3,}
echo dict['x']
echo dict.y
let var = 'z'
echo dict[var]
let dict['u'] = 4
let dict.v = 5
echo dict
```

### 删除变量

参考：

```vim
unlet list[1] | echo list
unlet list[-1] | echo list
unlet dict['u'] | echo dict
unlet dict.v | echo dict
```

### 浮点数

参考：

```vim
echo 1.23e3
let int = 123 | let float = 1.23 | let str = 'string'
echo str . int
echo str . float
echo str . 5 / 3.0
echo str . 5 % 3.0
echo round(5/3.0)
echo round(5/3.0) == 2
echo round(5/3.0) . str
```

TIPS：

* 整数可以转换为浮点数，反则不行
* 浮点数不能转化为字符串
* 浮点数取整后依然为浮点数

想将一个浮点数转换为“真正”的整数，可用如下操作:

```vim
echo string(round(5/3.0))
```

### 类型判断

参考：

```vim
if type(var) == v:t_list
if type(var) == 3
if type(var) == type([])
```

### 选择与比较

if：

```lua
:if {expr}
:    " todo
:endif
```

### 逻辑值与条件表达式

```vim
if 1  | echo v:true | endif
if 0 | echo v:true | endif
if -1 | echo v:true | endif

if "0" | echo v:true | endif
if '1' | echo v:true | endif
if ''  | echo v:true | endif
if 'a' | echo v:true | endif

if 1.23 | echo v:true | endif
if 0.23 | echo v:true | endif
if '0.23' | echo v:true | endif
if '1.23' | echo v:true | endif

if [1,2,3] | echo v:true | endif
if [] | echo v:true | endif
if {'x': 1} | echo v:true | endif
if {} | echo v:true | endif
```


TIPS：`nnoremap <leader>r yy:<C-r>*<CR>j`

